/*
    Simplified Version of
    CVE-ID:     CVE-2019-16880
    FROM:       https://github.com/strake/linea.rs/blob/218027e38e570a26778e07a2b6775dc3b540bc81/src/lib.rs
    LICENSE:    MIT License + Apache License 2.0 Copyright M Farkas-Dyck
*/

#![feature(start)]

use core::mem;
use core::ops::*;
use core::ptr;
use generic_array::*;
use idem::*;
use typenum::consts::{ U1, U2, U3, U4 };


pub struct Matrix<A, M: ArrayLength<A>, N: ArrayLength<GenericArray<A, M>> = U1>(GenericArray<GenericArray<A, M>, N>);

impl<A, M: ArrayLength<A>, N: ArrayLength<GenericArray<A, M>>> Matrix<A, M, N> {
    #[inline] fn map_elements<B, F: FnMut(A) -> B>(self, mut f: F) -> Matrix<B, M, N>
      where M: ArrayLength<B>, N: ArrayLength<GenericArray<B, M>> {
        let Matrix(a) = self;
        let mut c: GenericArray<GenericArray<B, M>, N> = unsafe { mem::uninitialized() };
        for i in 0..N::to_usize() { for j in 0..M::to_usize() { unsafe {
            ptr::write(&mut c[i][j], f(ptr::read(&a[i][j])))
        } } }
        mem::forget(a);
        Matrix(c)
    }
}

#[inline]
fn zip_elements<A, B, C, M, N, F: FnMut(A, B) -> C>(Matrix(a): Matrix<A, M, N>,
                                                    Matrix(b): Matrix<B, M, N>,
                                                    mut f: F) -> Matrix<C, M, N>
  where M: ArrayLength<A> + ArrayLength<B> + ArrayLength<C>,
        N: ArrayLength<GenericArray<A, M>> + ArrayLength<GenericArray<B, M>> +
           ArrayLength<GenericArray<C, M>> {
    let mut c: GenericArray<GenericArray<C, M>, N> = unsafe { mem::uninitialized() };
    for i in 0..N::to_usize() { for j in 0..M::to_usize() { unsafe {
        ptr::write(&mut c[i][j], f(ptr::read(&a[i][j]), ptr::read(&b[i][j])))
    } } }
    mem::forget((a, b));
    Matrix(c)
}

impl<A: Copy + Zero, M: ArrayLength<A>, N: ArrayLength<GenericArray<A, M>>> Matrix<A, M, N> {
    #[inline] pub fn zero() -> Self {
        let mut c: GenericArray<GenericArray<A, M>, N> = unsafe { mem::uninitialized() };
        for i in 0..N::to_usize() { for j in 0..M::to_usize() { c[i][j] = A::zero } }
        Matrix(c)
    }
}

#[start]
fn main(_argc: isize, _argv: *const *const u8) -> isize {
    let z0: Matrix<u32, U3, U4> = Matrix::zero();
    let z1: Matrix<u32, U3, U4> = z0.map_elements(|x| x+1);
    let z2: Matrix<u32, U3, U4> = Matrix::zero();
    let z3: Matrix<u32, U3, U4> = zip_elements(z2, z1, |a, b| a+b);
    0
}