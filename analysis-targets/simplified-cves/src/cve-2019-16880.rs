/*
    Simplified Version of
    CVE-ID:     CVE-2019-16880
    FROM:       https://github.com/strake/linea.rs/blob/218027e38e570a26778e07a2b6775dc3b540bc81/src/lib.rs
    LICENSE:    MIT License + Apache License 2.0 Copyright M Farkas-Dyck
*/

#![feature(start)]
#![allow(deprecated)]

use core::mem;
use core::ops::*;
use core::panic;
use core::ptr;
use generic_array::*;
use idem::*;
use typenum::consts::U1;


pub struct Matrix<A, M: ArrayLength<A>, N: ArrayLength<GenericArray<A, M>> = U1>(GenericArray<GenericArray<A, M>, N>);

impl<A, M: ArrayLength<A>, N: ArrayLength<GenericArray<A, M>>> Matrix<A, M, N> {
    #[inline] fn map_elements<B, F: FnMut(A) -> B>(self, mut f: F) -> Matrix<B, M, N>
      where M: ArrayLength<B>, N: ArrayLength<GenericArray<B, M>> {
        let Matrix(a) = self;
        let mut c: GenericArray<GenericArray<B, M>, N> = unsafe { mem::uninitialized() };
        for i in 0..N::to_usize() { for j in 0..M::to_usize() { unsafe {
            // DOUBLE-FREE: if f() elements of `a` will be dropped twice
            ptr::write(&mut c[i][j], f(ptr::read(&a[i][j])))
        } } }
        mem::forget(a);
        Matrix(c)
    }
}

#[inline]
fn zip_elements<A, B, C, M, N, F: FnMut(A, B) -> C>(Matrix(a): Matrix<A, M, N>,
                                                    Matrix(b): Matrix<B, M, N>,
                                                    mut f: F) -> Matrix<C, M, N>
  where M: ArrayLength<A> + ArrayLength<B> + ArrayLength<C>,
        N: ArrayLength<GenericArray<A, M>> + ArrayLength<GenericArray<B, M>> +
           ArrayLength<GenericArray<C, M>> {
    let mut c: GenericArray<GenericArray<C, M>, N> = unsafe { mem::uninitialized() };
    for i in 0..N::to_usize() { for j in 0..M::to_usize() { unsafe {
        // DOUBLE-FREE: if f() elements of `a` and `b` will be dropped twice
        ptr::write(&mut c[i][j], f(ptr::read(&a[i][j]), ptr::read(&b[i][j])))
    } } }
    mem::forget((a, b));
    Matrix(c)
}


// NOTE: original CVE has A: Copy + Zero
// but this does not matter to the unsafety of zip_elements and map_elements
impl<A: Zero, M: ArrayLength<A>, N: ArrayLength<GenericArray<A, M>>> Matrix<A, M, N> {
    #[inline] pub fn zero() -> Self {
        let mut c: GenericArray<GenericArray<A, M>, N> = unsafe { mem::uninitialized() };
        for i in 0..N::to_usize() { for j in 0..M::to_usize() { c[i][j] = A::zero } }
        Matrix(c)
    }
}


#[derive(Clone)]
struct DropCount(u32);

impl Drop for DropCount {
    fn drop(&mut self) {
        self.0 += 1;
        println!("Dropped {} times", self.0);
    }
}

impl idem::Zero for DropCount {
    #[allow(non_upper_case_globals)]
    const zero: Self = DropCount(0);
}

#[start]
fn main(_argc: isize, _argv: *const *const u8) -> isize {
    // we need catch_unwind as panicing within a #[start] item is undefined behavior
    let _ = std::panic::catch_unwind(|| {
        let z: Matrix<DropCount, U1, U1> = Matrix::zero();
        let _x = z.map_elements(|_| panic!("double free"));
        });
    let _ = std::panic::catch_unwind(|| {
        let y: Matrix<DropCount, U1, U1> = Matrix::zero();
        let z: Matrix<DropCount, U1, U1> = Matrix::zero();
        let _x = zip_elements(y, z, |_, _| panic!("double free"));
    });
    0
}